---
title: 'Server Actions & Mutations'
description: 'Handle form submissions and data mutations with NextJS Server Actions'
---

## What are Server Actions?

Server Actions are **asynchronous functions that run on the server**. They enable you to handle form submissions and data mutations without building a separate API.

<Info>
Server Actions are marked with the `'use server'` directive and can be called from both Server Components and Client Components.
</Info>

### Key Benefits

<CardGroup cols={2}>
  <Card title="No API Routes" icon="route">
    Handle mutations without creating API endpoints
  </Card>
  <Card title="Progressive Enhancement" icon="arrow-progress">
    Forms work without JavaScript enabled
  </Card>
  <Card title="Type Safety" icon="shield-check">
    Full TypeScript support end-to-end
  </Card>
  <Card title="Revalidation" icon="arrows-rotate">
    Automatically revalidate cached data
  </Card>
</CardGroup>

## Creating a Server Action

There are two ways to define Server Actions:

### Inline Server Action

Define the action directly in a Server Component:

```jsx app/meals/share/page.js
import ImagePicker from '@/components/meals/image-picker';
import classes from './page.module.css';

export default function ShareMealPage() {
  async function shareMeal(formData) {
    'use server';

    const meal = {
      title: formData.get('title'),
      summary: formData.get('summary'),
      instructions: formData.get('instructions'),
      image: formData.get('image'),
      creator: formData.get('name'),
      creator_email: formData.get('email')
    }

    console.log(meal);
  }

  return (
    <>
      <header className={classes.header}>
        <h1>
          Share your <span className={classes.highlight}>favorite meal</span>
        </h1>
        <p>Or any other meal you feel needs sharing!</p>
      </header>
      <main className={classes.main}>
        <form className={classes.form} action={shareMeal}>
          <div className={classes.row}>
            <p>
              <label htmlFor="name">Your name</label>
              <input type="text" id="name" name="name" required />
            </p>
            <p>
              <label htmlFor="email">Your email</label>
              <input type="email" id="email" name="email" required />
            </p>
          </div>
          <p>
            <label htmlFor="title">Title</label>
            <input type="text" id="title" name="title" required />
          </p>
          <p>
            <label htmlFor="summary">Short Summary</label>
            <input type="text" id="summary" name="summary" required />
          </p>
          <p>
            <label htmlFor="instructions">Instructions</label>
            <textarea
              id="instructions"
              name="instructions"
              rows="10"
              required
            ></textarea>
          </p>
          <ImagePicker label="Your image" name="image" />
          <p className={classes.actions}>
            <button type="submit">Share Meal</button>
          </p>
        </form>
      </main>
    </>
  );
}
```

<Accordion title="How it works">
1. User fills out the form
2. Form submits to the `shareMeal` action
3. NextJS automatically serializes form data
4. Function executes on the server
5. Console.log appears in your terminal (not browser!)
</Accordion>

### Separate Server Actions File

For better organization and reusability, create a separate actions file:

```jsx lib/actions.js
'use server';

export async function shareMeal(formData) {
  const meal = {
    title: formData.get('title'),
    summary: formData.get('summary'),
    instructions: formData.get('instructions'),
    image: formData.get('image'),
    creator: formData.get('name'),
    creator_email: formData.get('email'),
  };

  console.log(meal);
}
```

<Tip>
When using `'use server'` at the file level, **all exported functions** in that file become Server Actions.
</Tip>

Then import and use it:

```jsx app/meals/share/page.js
import { shareMeal } from '@/lib/actions';

export default function ShareMealPage() {
  return (
    <form action={shareMeal}>
      {/* form fields */}
    </form>
  );
}
```

## Real-World Example: User Management

Here's a complete example from the course:

```jsx actions/users.js
'use server';

import fs from 'node:fs';

export async function saveUserAction(formData) {
  console.log('Executed');
  const data = fs.readFileSync('dummy-db.json', 'utf-8');
  const instructors = JSON.parse(data);
  const newInstructor = {
    id: new Date().getTime().toString(),
    name: formData.get('name'),
    title: formData.get('title'),
  };

  instructors.push(newInstructor);
  fs.writeFileSync('dummy-db.json', JSON.stringify(instructors));
}
```

### Using in a Client Component

```jsx components/ServerActionsDemo.js
'use client';

import { saveUserAction } from '@/actions/users';

export default function ServerActionsDemo() {
  return (
    <div className="rsc">
      <h2>Server Actions</h2>
      <p>
        A "Form Action" converted to a "Server Action" via{' '}
        <strong>"use server"</strong>.
      </p>
      <p>Can be defined in a server component or a separate file.</p>
      <p>Can be called from inside server component or client component.</p>
      <form action={saveUserAction}>
        <p>
          <label htmlFor="name">User name</label>
          <input type="text" id="name" name="name" required />
        </p>
        <p>
          <label htmlFor="title">Title</label>
          <input type="text" id="title" name="title" required />
        </p>
        <p>
          <button>Save User</button>
        </p>
      </form>
    </div>
  );
}
```

<Info>
Server Actions can be called from **both** Server Components and Client Components. The function always executes on the server.
</Info>

## Form Validation

Add server-side validation to protect your data:

```jsx lib/actions.js
'use server';

import { redirect } from 'next/navigation';
import { saveMeal } from './meals';

function isInvalidText(text) {
  return !text || text.trim() === '';
}

export async function shareMeal(formData) {
  const meal = {
    title: formData.get('title'),
    summary: formData.get('summary'),
    instructions: formData.get('instructions'),
    image: formData.get('image'),
    creator: formData.get('name'),
    creator_email: formData.get('email'),
  };

  if (
    isInvalidText(meal.title) ||
    isInvalidText(meal.summary) ||
    isInvalidText(meal.instructions) ||
    isInvalidText(meal.creator) ||
    isInvalidText(meal.creator_email) ||
    !meal.creator_email.includes('@') ||
    !meal.image ||
    meal.image.size === 0
  ) {
    throw new Error('Invalid input');
  }

  await saveMeal(meal);
  redirect('/meals');
}
```

<Warning>
Always validate on the server! Client-side validation can be bypassed. Server-side validation is your security layer.
</Warning>

## Handling Form State with useFormState

Use the `useFormState` hook to return validation errors to the user:

```jsx lib/actions.js
'use server';

import { redirect } from 'next/navigation';
import { saveMeal } from './meals';

function isInvalidText(text) {
  return !text || text.trim() === '';
}

export async function shareMeal(prevState, formData) {
  const meal = {
    title: formData.get('title'),
    summary: formData.get('summary'),
    instructions: formData.get('instructions'),
    image: formData.get('image'),
    creator: formData.get('name'),
    creator_email: formData.get('email'),
  };

  if (
    isInvalidText(meal.title) ||
    isInvalidText(meal.summary) ||
    isInvalidText(meal.instructions) ||
    isInvalidText(meal.creator) ||
    isInvalidText(meal.creator_email) ||
    !meal.creator_email.includes('@') ||
    !meal.image ||
    meal.image.size === 0
  ) {
    return {
      message: 'Invalid input.',
    };
  }

  await saveMeal(meal);
  redirect('/meals');
}
```

<Accordion title="Key Changes for useFormState">
1. Action now receives `prevState` as first parameter
2. `formData` becomes second parameter
3. Return an object with error messages instead of throwing
4. Component can display the returned state
</Accordion>

### Using in Component

```jsx components/ShareMealForm.js
'use client';

import { useFormState } from 'react-dom';
import { shareMeal } from '@/lib/actions';

export default function ShareMealForm() {
  const [state, formAction] = useFormState(shareMeal, { message: null });

  return (
    <form action={formAction}>
      {state.message && <p className="error">{state.message}</p>}
      
      <p>
        <label htmlFor="title">Title</label>
        <input type="text" id="title" name="title" required />
      </p>
      
      {/* other form fields */}
      
      <button type="submit">Share Meal</button>
    </form>
  );
}
```

## Form Submission Status with useFormStatus

Show loading state during form submission:

```jsx components/SubmitButton.js
'use client';

import { useFormStatus } from 'react-dom';

export default function SubmitButton() {
  const { pending } = useFormStatus();

  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Submitting...' : 'Share Meal'}
    </button>
  );
}
```

<Info>
`useFormStatus` must be used in a component that is a **child** of the form, not in the component that renders the form itself.
</Info>

## Cache Revalidation

Invalidate cached data after mutations:

```jsx lib/actions.js
'use server';

import { revalidatePath } from 'next/cache';
import { redirect } from 'next/navigation';
import { saveMeal } from './meals';

export async function shareMeal(prevState, formData) {
  // ... validation and save logic
  
  await saveMeal(meal);
  
  // Revalidate the meals page cache
  revalidatePath('/meals');
  
  redirect('/meals');
}
```

<Steps>
  <Step title="Submit Form">
    User submits the form with new meal data
  </Step>
  <Step title="Server Action Runs">
    `shareMeal` validates and saves the meal
  </Step>
  <Step title="Cache Invalidation">
    `revalidatePath('/meals')` marks the meals cache as stale
  </Step>
  <Step title="Redirect">
    User redirected to meals page
  </Step>
  <Step title="Fresh Data">
    Page re-renders with updated data
  </Step>
</Steps>

### Revalidation Options

<CodeGroup>
```jsx Revalidate Specific Path
revalidatePath('/meals');
```

```jsx Revalidate All Paths
revalidatePath('/', 'layout');
```

```jsx Revalidate by Tag
revalidateTag('meals');
```
</CodeGroup>

## Progressive Enhancement

Server Actions work even if JavaScript is disabled:

```jsx
<form action={shareMeal}>
  <input type="text" name="title" required />
  <button type="submit">Submit</button>
</form>
```

<Tip>
This form will work with or without JavaScript! NextJS handles the submission server-side automatically.
</Tip>

## Error Handling

Handle errors gracefully in Server Actions:

```jsx lib/actions.js
'use server';

export async function shareMeal(prevState, formData) {
  try {
    const meal = {
      title: formData.get('title'),
      // ... other fields
    };

    // Validation
    if (isInvalidText(meal.title)) {
      return {
        message: 'Invalid input.',
      };
    }

    await saveMeal(meal);
    revalidatePath('/meals');
    redirect('/meals');
  } catch (error) {
    return {
      message: 'Failed to save meal. Please try again.',
    };
  }
}
```

## Best Practices

<AccordionGroup>
  <Accordion title="Always Validate on Server">
    Never trust client data. Validate all inputs in your Server Actions.
  </Accordion>
  
  <Accordion title="Use Separate Files">
    Keep Server Actions in dedicated files (e.g., `lib/actions.js`) for better organization and reusability.
  </Accordion>
  
  <Accordion title="Return Meaningful Errors">
    Use `useFormState` to return specific error messages that help users fix issues.
  </Accordion>
  
  <Accordion title="Revalidate After Mutations">
    Always call `revalidatePath()` or `revalidateTag()` after data changes to keep cache fresh.
  </Accordion>
  
  <Accordion title="Show Loading States">
    Use `useFormStatus` to provide feedback during form submission.
  </Accordion>
</AccordionGroup>

## Server Actions vs API Routes

| Feature | Server Actions | API Routes |
|---------|----------------|------------|
| Setup | Minimal (just `'use server'`) | Create separate files |
| Type Safety | Full end-to-end | Manual type definitions |
| Form Integration | Native HTML forms | Requires fetch/axios |
| Progressive Enhancement | Yes | No |
| Revalidation | Built-in | Manual |
| Use Case | Form submissions, mutations | Public APIs, webhooks |

<Info>
Use Server Actions for internal data mutations. Use API Routes when you need a public API endpoint or webhook.
</Info>

## Complete Example: Full CRUD Flow

<Steps>
  <Step title="Create Action File">
    ```jsx lib/actions.js
    'use server';
    
    export async function createMeal(formData) { /* ... */ }
    export async function updateMeal(id, formData) { /* ... */ }
    export async function deleteMeal(id) { /* ... */ }
    ```
  </Step>
  
  <Step title="Build Form Component">
    ```jsx components/MealForm.js
    'use client';
    import { useFormState } from 'react-dom';
    import { createMeal } from '@/lib/actions';
    // Component code...
    ```
  </Step>
  
  <Step title="Add Validation">
    Validate inputs server-side and return errors
  </Step>
  
  <Step title="Revalidate Cache">
    Invalidate affected pages after mutations
  </Step>
  
  <Step title="Redirect">
    Navigate user to success page
  </Step>
</Steps>

## Next Steps

<CardGroup cols={2}>
  <Card title="Database Integration" icon="database">
    Connect Server Actions to PostgreSQL, MongoDB, or other databases
  </Card>
  <Card title="File Uploads" icon="upload">
    Handle file uploads in Server Actions
  </Card>
  <Card title="Authentication" icon="lock">
    Protect Server Actions with authentication
  </Card>
  <Card title="Optimistic Updates" icon="bolt">
    Update UI immediately before server confirmation
  </Card>
</CardGroup>
